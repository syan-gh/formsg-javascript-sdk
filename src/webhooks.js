'use strict';

var url = require('url');

var _require = require('./util/signature'),
    sign = _require.sign,
    verify = _require.verify;

var _require2 = require('../src/util/parser'),
    parseSignatureHeader = _require2.parseSignatureHeader;

var WEBHOOK_KEYS = require('../resource/webhook-keys');
var STAGE = require('./util/stage');

/**
 * Helpfer function to construct the basestring and verify the signature of an incoming request
 * @param {string} uri String
 * @param {string} submissionId MongoDB submission ObjectId
 * @param {string} formId MongoDB submission ObjectId
 * @param {Number} epoch Number of milliseconds since Jan 1, 1970
 * @param {string} signature base64 encoded signature
 * @param {string} webhookPublicKey base64 webhook public key
 */
function verifySignature(uri, submissionId, formId, epoch, signature, webhookPublicKey) {
  var baseString = url.parse(uri).href + '.' + submissionId + '.' + formId + '.' + epoch;
  return verify(baseString, signature, webhookPublicKey);
}

/**
 * Helper function to verify that the epoch submitted is recent.
 * Prevents against replay attacks.
 * @param {Number} epoch The number of milliseconds since Jan 1, 1979
 * @param {Number} [expiry=30000] Duration of expiry. The default is 5 minutes.
 */
function verifyEpoch(epoch) {
  var expiry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300000;

  var difference = Date.now() - epoch;
  return difference > 0 && difference < expiry;
}

/**
 * Partial function that injects the webhook public key for authentication
 * @param {string} webhookPublicKey The FormSG webhook public key
 * @param {string} header X-FormSG-Signature header
 * @param {string} uri The endpoint that FormSG is POSTing to
 * @returns {function}
 * @throws {Error} If the signature or uri cannot be verified
 */
var authenticate = function authenticate(webhookPublicKey) {
  return function (header, uri) {
    // Parse the header
    var _parseSignatureHeader = parseSignatureHeader(header),
        signature = _parseSignatureHeader.v1,
        t = _parseSignatureHeader.t,
        submissionId = _parseSignatureHeader.s,
        formId = _parseSignatureHeader.f;

    var epoch = Number(t);

    if (!epoch || !signature || !submissionId || !formId) {
      throw new Error('X-FormSG-Signature header is invalid');
    }

    // Verify signature authenticity
    if (!verifySignature(uri, submissionId, formId, epoch, signature, webhookPublicKey)) {
      throw new Error('Signature could not be verified for uri=' + uri + ' submissionId=' + submissionId + ' formId=' + formId + ' epoch=' + epoch + ' signature=' + signature);
    }

    // Verify epoch recency
    if (!verifyEpoch(epoch)) {
      throw new Error('Signature is not recent for uri=' + uri + ' submissionId=' + submissionId + ' formId=' + formId + ' epoch=' + epoch + ' signature=' + signature);
    }
  };
};

/**
 * Generates a signature based on the URI, submission ID and epoch timestamp.
 * @param {String} webhookSecretKey The base64 secret key
 * @param {String} uri Full URL of the request
 * @param {Object} submissionId Submission Mongo ObjectId saved to the database
 * @param {Number} epoch Number of milliseconds since Jan 1, 1970
 */
var generateSignature = function generateSignature(webhookSecretKey) {
  return function (_ref) {
    var uri = _ref.uri,
        submissionId = _ref.submissionId,
        formId = _ref.formId,
        epoch = _ref.epoch;

    var baseString = url.parse(uri).href + '.' + submissionId + '.' + formId + '.' + epoch;
    return sign(baseString, webhookSecretKey);
  };
};

/**
 * Constructs the `X-FormSG-Signature` header
 * @param {string} epoch Epoch timestamp
 * @param {string} submissionId Mongo ObjectId
 * @param {string} formId Mongo ObjectId
 * @param {string} signature A signature generated by the generateSignature() function
 */
function constructHeader(_ref2) {
  var epoch = _ref2.epoch,
      submissionId = _ref2.submissionId,
      formId = _ref2.formId,
      signature = _ref2.signature;

  return 't=' + epoch + ',s=' + submissionId + ',f=' + formId + ',v1=' + signature;
}

/**
 * Retrieves the appropriate webhook public key.
 * Defaults to production.
 * @param {string} [mode] One of 'staging' | 'production'
 */
function getWebhookPublicKey(mode) {
  switch (mode) {
    case STAGE.staging:
      return WEBHOOK_KEYS.staging.publicKey;
    case STAGE.test:
      return WEBHOOK_KEYS.test.publicKey;
    default:
      return WEBHOOK_KEYS.production.publicKey;
  }
}

/**
 * Provider that accepts configuration
 * before returning the webhooks module
 */
module.exports = function (_ref3) {
  var mode = _ref3.mode,
      webhookSecretKey = _ref3.webhookSecretKey;

  var webhookPublicKey = getWebhookPublicKey(mode);

  return {
    /* Verification functions */
    authenticate: authenticate(webhookPublicKey),
    /* Signing functions */
    generateSignature: webhookSecretKey ? generateSignature(webhookSecretKey) : undefined,
    constructHeader: webhookSecretKey ? constructHeader : undefined
  };
};